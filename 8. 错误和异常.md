文档写到现在也没有提及到错误信息，但是你也能从之前的例子中看到一些错误的定义和捕获，python至少有两种可区分的错误：语法错误(error)和程序异常(exception)

### 8.1. 语法错误(Syntax Errors)
语法，也就是为人所知的解析错误，也是你在学习Python过程中抱怨最多的事情

```
>>> while True print('Hello world')
  File "<stdin>", line 1
    while True print('Hello world')
                   ^
SyntaxError: invalid syntax
```
解析器会将出错的行重新打印出来，并且使用一个小小的箭头指向最初检测到错误的位置，错误是发生在(至少检测是这样)箭头指向位置之前，在上述例子中，检测到的错误发生在print()，是因为在print之前缺少冒号，文件名和行号也打印了，这样就能精确定位错误，方便查找错误
### 8.2 异常(Exception)
即使语句和表达式的语法是正确的，也可能在执行的时候产生一个错误，在执行期间检测到的错误叫做异常，当然异常也不是百分百会让程序奔溃，你将很快学会如何在python编程中处理它们。大部分的异常不是由程序控制的，但是，异常结果都是如下所示的模式：

```
>>> 10 * (1/0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
>>> 4 + spam*3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'spam' is not defined
>>> '2' + 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly
```
最后一行的错误信息会指明发生了什么， 异常的来源形形色色，打印异常信息的时候也会带上异常的类型，例子中的异常类型就是ZeroDivisionError，NameError和TypeError。表示异常类型的字符串和在python内置异常定义的名称是一致的，这对于所有的内置异常来说是正确的，但是对于用户定义的异常来说就有可能不太对(虽然这是公约)。标准的异常名称是内置的标识符(不包括预留字)

剩下的信息是基于异常类型的详细信息以及是什么造成异常的

### 8.3 异常处理
对于可能发生的已知异常可以进行处理，请看下面的例子，要求用户输入一个整数，当用户输入一个非法的整数时，则捕获该异常，并且允许用户终端程序（使用Control-C或者任意的操作系统支持的方式），注意： 用户生成的中断在程序中表示的抛出一个叫做 KeyboardInterrupt的异常

```
>>> while True:
...     try:
...         x = int(input('Please enter a number: '))
...         break
...     except ValueError:
...         print('Oops! That was no valid number. Try again...')
...
```
try语句工作流程如下：
* 首先， try子句(在try和except之间的语句)已经执行
* 如果没有异常产生，那么except子句就不执行并且结束try语句
* 当执行try字句时发生了异常，try语句剩下的代码不会执行。如何该异常的类型是except后面声明的异常类型，则会执行except中的字句。并且会执行try语句后代码
* 如何异常发生了并且和except声明的异常类型并不匹配，那么就会跳出当前的try语句，并把异常上传给上一级，如果没有找到处理该异常类型的代码，这就是个未处理异常并且解释器会终止执行程序，并输出带有该异常的如上类似的信息

一个try语句可能不止一个except的子句，针对性的处理不同的异常，但是最多只会有一个异常处理会被执行，处理器只会处理和try中发生的一致的异常，而不会处理相同try语句下的其它异常处理。一个except子句可能命名了多个异常并且这些异常是一个使用括号括起来的元组，如下所示：
```
... except (RuntimeError, TypeError, NameError):
...     pass 
```

如果一个类是except的子句中的异常类的相同类或者派生类，则该except异常捕获会捕获该异常(如果是相反的情况，该类是except子句异常类的基类，则无法捕获该异常)， 例如，下面的代码将会按顺序打印出B、C、D
```
>>> class B(Exception):
...     pass
...
>>> class C(B):
...     pass
...
>>> class D(C):
...     pass
...
>>>
>>> for cls in [B, C, D]:
...     try:
...             raise cls()
...     except D:
...             print('D')
...     except C:
...             print('C')
...     except B:
...             print('B')
...
```
请注意： 如果这个except子句是相反的结构(先处理的是B异常)，那么它将打印的是B, B, B ——第一个except子句将会触发

最后一个except的子句可能会忽略exception的名称，以此作为通配符。当然使用的时候要异常小心，因为这样做很容易掩饰一个真实的编程错误，这也经常用于打印出一个错误信息以及重新抛出该异常(使得调用者可以捕获并处理该异常信息)

```
>>> import sys
>>>
>>> try:
...     f = open('myfile.txt')
...     s = f.readline()
...     i = int(s.strip())
... except OSError as error:
...     print('OS error: {0}'.format(err))
... except ValueError:
...     print('Could not convert data to an integer.')
... except:
...     print('Unexcepted error: {0}', sys.exc_info()[0])
...     raise
```

try...except语句还有个可选的else子句， 但是必须放在所有的except子句的下面，这对于try语句没有出现异常则代码继续运行很有帮助，如下所示：
```
for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except OSError:
        print('cannot open', arg)
    else:
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()
```
